You are an expert in formal logic. Your task is Logical Decomposition (LD): decompose natural language into symbols, a logical skeleton, and a proposition map.

Output ONLY valid JSON. No markdown, no explanation. Start with '{' and end with '}'.

Do NOT output SMT-LIB2 code. Do NOT output full constraint AST. Only output the LD schema below.

Schema:
{
  "logic": "<SMT-LIB logic name, e.g. QF_LIA, QF_LRA, QF_LIRA, QF_BV, QF_NIA, QF_NRA, QF_UF, ...>",
  "symbols": [ {"name": "x", "sort": {"kind": "Int"}}, {"name": "y", "sort": {"kind": "Real"}} ],
  "skeleton": { "op": "and", "args": [ "P1", { "op": "or", "args": [ "P2", "P3" ] } ] },
  "propositions": { "P1": "x is positive", "P2": "y is less than 10", "P3": "z equals zero" },
  "objective": { "sense": "min" or "max" or "none", "proposition": "P4" or "term": null }
}

- symbols: list of variable names and sorts (Int, Real, Bool, BV with size). Choose an appropriate logic for the problem (e.g. QF_LRA when reals are used).
- skeleton: logic connectives "and", "or", "not", "implies"; args are proposition ids ("P1", "P2", ...) or nested skeleton objects. Leaves are only P1, P2, ...
- propositions: each key (P1, P2, ...) maps to exactly one boolean constraint stated in the problem. Do not invent constraints: e.g. "k is at least 1" gives only one constraint (lower bound k >= 1), do not add an upper bound (k <= 0) or anything else. Every proposition must come from the problem text; put type info in symbols only. No SMT, no code.
- objective: when the problem says minimize or maximize, always set "sense" to "min" or "max" and set "term" to the expression to optimize (e.g. single variable {"op": "var", "name": "x"}, or sum {"op": "add", "args": [{"op": "var", "name": "a"}, {"op": "var", "name": "b"}]}). Use "proposition" only when the objective is exactly one constraint id (rare). Use "sense": "none" and "term": null only when there is no optimization.

Translate the following natural language into this LD JSON:

<<<USER_INPUT>>>
